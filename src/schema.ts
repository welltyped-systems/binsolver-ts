/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Service banner */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Plain text banner. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        /** @example BinSolver API */
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Health check */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Service is healthy. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        /** @example ok */
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pack": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Pack items into bins */
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Optional request correlation id. */
                    "x-request-id"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["PackRequest"];
                };
            };
            responses: {
                /** @description Packing result. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PackResponse"];
                    };
                };
                /** @description Invalid payload or limits exceeded. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Missing or invalid API key. */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Usage exceeded. */
                402: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Forbidden. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Request timeout. */
                408: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Rate limited. */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Upstream auth provider error. */
                502: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/pack": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Pack items into bins */
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Optional request correlation id. */
                    "x-request-id"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["PackRequest"];
                };
            };
            responses: {
                /** @description Packing result. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PackResponse"];
                    };
                };
                /** @description Invalid payload or limits exceeded. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Missing or invalid API key. */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Usage exceeded. */
                402: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Forbidden. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Request timeout. */
                408: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Rate limited. */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Upstream auth provider error. */
                502: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        PackRequest: {
            /** @description Items to pack (expanded by quantity). Maximum items per request is plan-dependent (free 100, paid 1000). */
            items: components["schemas"]["ItemInput"][];
            /** @description Bin templates to pack into. Maximum bin types per request is plan-dependent (free 50, paid 200). */
            bins: components["schemas"]["BinInput"][];
            /** @description When false, the request fails if any item cannot be placed. Defaults to true. */
            allowUnplaced?: boolean;
            /**
             * @description Packing objective (speed, bins used, placed count, waste minimization, cost, or shipping). minCost requires bin cost values; shipping requires bin shipping profiles. Defaults to 'fast'.
             * @enum {string}
             */
            objective?: "fast" | "minBins" | "maxPlaced" | "minWaste" | "minCost" | "shipping";
            /** @description Weights for shipping-aware optimization. Used when objective=shipping; can also tune shipping scoring while using other objectives. */
            shippingObjective?: components["schemas"]["ShippingObjectiveInput"];
            /** @description Two-stage packing (items->pallets->containers). Returns pallet results and split assignments. (Paid plan only) */
            palletization?: components["schemas"]["PalletizationInput"];
            /** @description If true, returns step-by-step packing instructions for each bin. (Paid plan only) Defaults to false. */
            includeInstructions?: boolean;
            /**
             * @description If 'zpl', generates a ZPL label string for each bin. (Paid plan only) Defaults to 'none'.
             * @enum {string}
             */
            labelFormat?: "none" | "zpl";
            /**
             * @description Controls pre-pack nesting. auto uses the main objective to decide nesting; maximize fills cavities first; none disables nesting. Defaults to 'auto'.
             * @enum {string}
             */
            nestingStrategy?: "auto" | "maximize" | "none";
        };
        ItemInput: {
            /** @description Optional item identifier. If omitted, the API assigns one. */
            id?: string;
            /**
             * Format: double
             * @description Item width (X axis).
             */
            w: number;
            /**
             * Format: double
             * @description Item height (Y axis).
             */
            h: number;
            /**
             * Format: double
             * @description Item depth (Z axis).
             */
            d: number;
            /**
             * Format: double
             * @description Weight of a single unit of this item (used for load limits and shipping).
             */
            weight?: number;
            /** @description If true, the item can be rotated 90 degrees on any axis. Defaults to true. */
            allowRotation?: boolean;
            /** @description Detailed rotation rules (overrides allowRotation when provided). */
            rotation?: components["schemas"]["RotationRulesInput"];
            /** @description Stacking constraints for stability and load. */
            stacking?: components["schemas"]["StackingRulesInput"];
            /** @description Grouping, hazmat, fragile, and padding rules. */
            packaging?: components["schemas"]["PackagingRulesInput"];
            /** @description When set, total expanded items must remain within plan limits (free 100, paid 1000). */
            quantity?: number;
        };
        BinInput: {
            /** @description Optional bin identifier. If omitted, the API assigns one. */
            id?: string;
            /**
             * Format: double
             * @description Bin width (X axis).
             */
            w: number;
            /**
             * Format: double
             * @description Bin height (Y axis).
             */
            h: number;
            /**
             * Format: double
             * @description Bin depth (Z axis).
             */
            d: number;
            /**
             * Format: double
             * @description Maximum weight capacity of this bin (sum of item weights).
             */
            maxWeight?: number;
            /**
             * Format: double
             * @description Cost of using this bin (required for minCost objective).
             */
            cost?: number;
            /**
             * Format: double
             * @description Empty weight of the bin or pallet (added to shipment weight).
             */
            tareWeight?: number;
            /** @description If false, hazmat items cannot be placed in this bin. Defaults to true. */
            allowHazmat?: boolean;
            /** @description Clearance between items and bin walls (shrinks usable interior). */
            padding?: components["schemas"]["PaddingInput"];
            /** @description Shipping profile for this bin (required for objective=shipping). */
            shipping?: components["schemas"]["ShippingInput"];
            /** @description When set, must not exceed plan limits (free 100, paid 1000). */
            quantity?: number;
        };
        PackResponse: {
            /** @description Packed bins (containers) with placements. */
            bins: components["schemas"]["BinResult"][];
            /** @description Packed pallets when palletization is enabled. */
            pallets?: components["schemas"]["BinResult"][];
            /** @description Items that could not be placed. */
            unplaced: components["schemas"]["UnplacedItem"][];
            /** @description Pallets that could not be placed into containers. */
            unplacedPallets?: components["schemas"]["UnplacedPallet"][];
            /** @description Item-to-container assignments with pallet audit trails. */
            splits?: components["schemas"]["SplitAssignment"][];
            stats: components["schemas"]["PackStats"];
        };
        BinResult: {
            /** @description Instance id for the packed bin. */
            binId: string;
            /** @description Template id from the request. */
            templateId: string;
            /**
             * Format: double
             * @description Bin width.
             */
            w: number;
            /**
             * Format: double
             * @description Bin height.
             */
            h: number;
            /**
             * Format: double
             * @description Bin depth.
             */
            d: number;
            /**
             * Format: double
             * @description Total weight of items in this bin.
             */
            weight?: number;
            /** @description Shipping cost/weight metrics for the packed bin (if shipping profile provided). */
            shipping?: components["schemas"]["ShippingResult"];
            /**
             * Format: uri
             * @description URL to replay this bin packing result in the BinSolver visualizer.
             */
            vizUrl: string;
            /**
             * Format: double
             * @description Volume utilization of the bin (0.0 to 1.0).
             */
            utilization: number;
            /** @description Item placements in this bin. */
            placements: components["schemas"]["Placement"][];
            /** @description Step-by-step packing instructions (if requested). */
            instructions?: string[];
            /** @description Generated label code (e.g. ZPL) for the bin (if requested). */
            label?: string;
        };
        Placement: {
            /** @description Item identifier for this placement. */
            itemId: string;
            /**
             * Format: double
             * @description X coordinate of the placement origin.
             */
            x: number;
            /**
             * Format: double
             * @description Y coordinate of the placement origin.
             */
            y: number;
            /**
             * Format: double
             * @description Z coordinate of the placement origin.
             */
            z: number;
            /**
             * Format: double
             * @description Packed width (includes item padding if provided).
             */
            w: number;
            /**
             * Format: double
             * @description Packed height (includes item padding if provided).
             */
            h: number;
            /**
             * Format: double
             * @description Packed depth (includes item padding if provided).
             */
            d: number;
            /**
             * @description Applied rotation permutation.
             * @enum {string}
             */
            rotation: "xyz" | "xzy" | "yxz" | "yzx" | "zxy" | "zyx";
            /** @description Items packed inside this item (if nesting was used). Coordinates are relative to the item's local origin. */
            nested?: components["schemas"]["NestedPlacement"][];
        };
        NestedPlacement: {
            /** @description Item identifier for this placement. */
            itemId: string;
            /**
             * Format: double
             * @description X coordinate of the placement origin (relative to container).
             */
            x: number;
            /**
             * Format: double
             * @description Y coordinate of the placement origin (relative to container).
             */
            y: number;
            /**
             * Format: double
             * @description Z coordinate of the placement origin (relative to container).
             */
            z: number;
            /**
             * Format: double
             * @description Packed width (includes item padding if provided).
             */
            w: number;
            /**
             * Format: double
             * @description Packed height (includes item padding if provided).
             */
            h: number;
            /**
             * Format: double
             * @description Packed depth (includes item padding if provided).
             */
            d: number;
            /**
             * @description Applied rotation permutation.
             * @enum {string}
             */
            rotation: "xyz" | "xzy" | "yxz" | "yzx" | "zxy" | "zyx";
        };
        UnplacedItem: {
            /** @description Item identifier. */
            itemId: string;
            /**
             * Format: double
             * @description Item width.
             */
            w: number;
            /**
             * Format: double
             * @description Item height.
             */
            h: number;
            /**
             * Format: double
             * @description Item depth.
             */
            d: number;
            /**
             * Format: double
             * @description Item weight.
             */
            weight?: number;
            /** @description Reason code for why the item was not placed (e.g., no_fit, pallet_unplaced). */
            reason: string;
        };
        UnplacedPallet: {
            /** @description Pallet instance id. */
            palletId: string;
            /** @description Reason code for why the pallet was not placed. */
            reason: string;
        };
        SplitAssignment: {
            /** @description Item identifier. */
            itemId: string;
            /** @description Container/bin identifier where the item ultimately lands. */
            binId: string;
            /** @description Pallet identifier if palletization was used. */
            palletId?: string;
        };
        ShippingResult: {
            /**
             * Format: double
             * @description max(actual weight, dimensional weight).
             */
            billableWeight: number;
            /**
             * Format: double
             * @description Dimensional weight computed from bin volume and divisor.
             */
            dimensionalWeight: number;
            /**
             * Format: double
             * @description Estimated shipping cost.
             */
            cost: number;
            /**
             * Format: double
             * @description Estimated carbon impact.
             */
            carbon: number;
            /**
             * Format: double
             * @description Estimated delivery time in days.
             */
            slaDays: number;
        };
        /** @description Controls which rotations are allowed for this item. */
        RotationRulesInput: {
            /** @description Rotation strategy. upright/noFlip keep height on Y axis. */
            mode?: components["schemas"]["RotationMode"];
            /** @description Allowed axis swaps when mode=axis. */
            allowAxes?: components["schemas"]["RotationAxes"];
            /** @description Allowed explicit rotations when mode=custom. */
            allowed?: ("xyz" | "xzy" | "yxz" | "yzx" | "zxy" | "zyx")[];
        };
        /**
         * @description Rotation mode selector.
         * @enum {string}
         */
        RotationMode: "any" | "none" | "upright" | "noFlip" | "axis" | "custom";
        /** @description Allowed axis swaps for axis-specific rotation control. */
        RotationAxes: {
            /** @description Allow swapping X and Y. */
            xy?: boolean;
            /** @description Allow swapping X and Z. */
            xz?: boolean;
            /** @description Allow swapping Y and Z. */
            yz?: boolean;
        };
        /** @description Stability and stacking constraints for this item. */
        StackingRulesInput: {
            /**
             * Format: double
             * @description Minimum supported base area ratio (0..1).
             */
            minSupportRatio?: number;
            /**
             * Format: double
             * @description Minimum supported base area (absolute units).
             */
            minSupportArea?: number;
            /**
             * Format: double
             * @description Maximum load this item can support above it.
             */
            maxLoad?: number;
            /**
             * Format: double
             * @description Maximum stacked height above this item.
             */
            maxStackHeight?: number;
            /** @description Require center-of-gravity to be supported. */
            requireCogSupport?: boolean;
        };
        /** @description Packaging and compatibility constraints. */
        PackagingRulesInput: {
            /** @description Group identifier. Items sharing the same group id are governed by groupMode. */
            group?: string;
            /** @description keepTogether packs the entire group in the same bin (or leaves all unplaced); separate isolates the group to its own bins. Defaults to keepTogether when group is set. */
            groupMode?: components["schemas"]["GroupMode"];
            /** @description Marks item as hazardous; requires allowHazmat=true on bins. */
            hazmat?: boolean;
            /** @description Marks item as fragile; prevents stacking weight above. */
            fragile?: boolean;
            /** @description When false, this item cannot be nested inside other items. Defaults to true. */
            nestable?: boolean;
            /** @description Defines an internal cavity so other items may be packed inside this item. */
            nesting?: components["schemas"]["NestingRulesInput"];
            /** @description Clearance added around the item dimensions. */
            padding?: components["schemas"]["PaddingInput"];
        };
        /** @description Internal cavity definition for nesting. */
        NestingRulesInput: {
            /**
             * Format: double
             * @description Inner cavity width (X axis).
             */
            innerW: number;
            /**
             * Format: double
             * @description Inner cavity height (Y axis).
             */
            innerH: number;
            /**
             * Format: double
             * @description Inner cavity depth (Z axis).
             */
            innerD: number;
            /** @description Clearance between nested items and cavity walls. */
            padding?: components["schemas"]["PaddingInput"];
            /**
             * Format: double
             * @description Maximum total weight allowed inside this cavity.
             */
            maxWeight?: number;
            /** @description If false, hazmat items cannot be nested inside this cavity. Defaults to true. */
            allowHazmat?: boolean;
            /** @description If set, only items whose packaging.group is in this list may be nested. */
            allowedGroups?: string[];
        };
        /**
         * @description Grouping mode for items sharing the same group id. groupMode without group is invalid.
         * @enum {string}
         */
        GroupMode: "keepTogether" | "separate";
        /** @description Padding/clearance values (all sets defaults for x/y/z). */
        PaddingInput: {
            /**
             * Format: double
             * @description Uniform padding on all axes.
             */
            all?: number;
            /**
             * Format: double
             * @description Padding on the X axis.
             */
            x?: number;
            /**
             * Format: double
             * @description Padding on the Y axis.
             */
            y?: number;
            /**
             * Format: double
             * @description Padding on the Z axis.
             */
            z?: number;
        };
        /** @description Shipping profile for a bin or container. */
        ShippingInput: {
            /**
             * Format: double
             * @description Fixed cost per shipment for this bin.
             */
            baseCost?: number;
            /**
             * Format: double
             * @description Variable cost per unit of billable weight.
             */
            ratePerWeight?: number;
            /**
             * Format: double
             * @description Divisor for dimensional weight (volume / divisor).
             */
            dimWeightDivisor?: number;
            /**
             * Format: double
             * @description Carbon cost per unit of billable weight.
             */
            carbonPerWeight?: number;
            /**
             * Format: double
             * @description Estimated delivery time for this bin.
             */
            slaDays?: number;
        };
        /** @description Weights used to score shipping tradeoffs during optimization. */
        ShippingObjectiveInput: {
            /**
             * Format: double
             * @description Weight applied to cost in the shipping objective.
             */
            costWeight?: number;
            /**
             * Format: double
             * @description Weight applied to carbon impact in the shipping objective.
             */
            carbonWeight?: number;
            /**
             * Format: double
             * @description Weight applied to SLA days in the shipping objective (lower is better).
             */
            slaWeight?: number;
            /**
             * Format: double
             * @description Override bin shipping dimWeightDivisor for optimization.
             */
            dimWeightDivisor?: number;
        };
        /** @description Two-stage packing: items -> pallets -> containers. */
        PalletizationInput: {
            /** @description Pallet templates used for the first packing stage. */
            pallets: components["schemas"]["BinInput"][];
            /** @description When false, all pallets must fit a single container template. */
            allowMixedContainers?: boolean;
        };
        PackStats: {
            /** @description Total items requested (after quantity expansion). */
            items: number;
            /** @description Number of items successfully placed. */
            placed: number;
            /** @description Number of items not placed. */
            unplaced: number;
            /** @description Number of items nested inside other items. */
            nested?: number;
            /** @description Number of bins used. */
            binsUsed: number;
            /** @description Number of pallets used (if palletization enabled). */
            palletsUsed?: number;
            /**
             * Format: int64
             * @description Packing duration in milliseconds.
             */
            durationMs: number;
            /** @description Echoed request id when provided. */
            requestId?: string;
        };
        ErrorResponse: {
            error: components["schemas"]["ErrorBody"];
        };
        ErrorBody: {
            /** @description Machine-readable error code. */
            code: string;
            /** @description Human-readable error message. */
            message: string;
            /** @description Request identifier when provided. */
            requestId?: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
